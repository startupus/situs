import { Injectable, UnauthorizedException, ConflictException, BadRequestException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import * as bcrypt from 'bcryptjs';
import { UsersService } from '../users/users.service';
import { CommunicationService } from '../communication/communication.service';
import { RegisterDto } from './dto/register.dto';
import { RegisterPublicDto } from './dto/register-public.dto';
import { SendCodeDto } from './dto/send-code.dto';
import { VerifyCodeDto } from './dto/verify-code.dto';
import { ForgotPasswordDto } from './dto/forgot-password.dto';
import { ResetPasswordDto } from './dto/reset-password.dto';
import { AuthResponseDto } from './dto/auth-response.dto';
import { User } from '../users/entities/user.entity';

/**
 * –°–µ—Ä–≤–∏—Å –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
 *
 * –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç:
 * - –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª–µ–π
 * - –ì–µ–Ω–µ—Ä–∞—Ü–∏—é JWT —Ç–æ–∫–µ–Ω–æ–≤
 * - –í–∞–ª–∏–¥–∞—Ü–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
 * - –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤
 */
@Injectable()
export class AuthService {
  constructor(
    private readonly usersService: UsersService,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly communicationService: CommunicationService,
  ) {}

  // –í—Ä–µ–º–µ–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –∫–æ–¥–æ–≤ (–≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Redis)
  private loginCodes = new Map<string, { code: string; expiresAt: Date; userId: string }>();
  private resetCodes = new Map<string, { code: string; expiresAt: Date; userId: string }>();

  /**
   * –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
   */
  async register(registerDto: RegisterDto): Promise<AuthResponseDto> {
    const { email, password, name } = registerDto;

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const existingUser = await this.usersService.findByEmail(email);
    if (existingUser) {
      throw new ConflictException('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç');
    }

    // –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è
    const hashedPassword = await this.hashPassword(password);

    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await this.usersService.create({
      email,
      password: hashedPassword,
      name,
    } as any);

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–æ–∫–µ–Ω–æ–≤
    return this.generateTokens(user);
  }

  /**
   * –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è Local Strategy
   */
  async validateUser(email: string, password: string): Promise<User | null> {
    const user = await this.usersService.findByEmail(email);

    if (user && (await this.comparePasswords(password, user.password))) {
      // –£–¥–∞–ª—è–µ–º –ø–∞—Ä–æ–ª—å –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
      const { password: _, ...result } = user;
      return result as User;
    }

    return null;
  }

  /**
   * –í—Ö–æ–¥ –≤ —Å–∏—Å—Ç–µ–º—É
   */
  async login(user: User): Promise<AuthResponseDto> {
    return this.generateTokens(user);
  }

  /**
   * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–æ–≤
   */
  async refreshTokens(refreshToken: string): Promise<AuthResponseDto> {
    try {
      const payload = this.jwtService.verify(refreshToken, {
        secret: this.configService.get<string>('jwt.secret'),
      });

      const user = await this.usersService.findById(payload.sub);
      if (!user) {
        throw new UnauthorizedException('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
      }

      return this.generateTokens(user as any);
    } catch (error) {
      throw new UnauthorizedException('–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π refresh —Ç–æ–∫–µ–Ω');
    }
  }

  /**
   * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è JWT —Ç–æ–∫–µ–Ω–æ–≤
   */
  private async generateTokens(user: any): Promise<AuthResponseDto> {
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é —Ä–æ–ª—å –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –µ–π —Å–∫–æ—É–ø—ã –¥–æ—Å—Ç—É–ø–∞
    const globalRole = ((user.globalRole || (user as any).global_role || 'BUSINESS') as string)
      .toString()
      .toUpperCase();

    const scopesByRole = (role: string): string[] => {
      switch (role) {
        case 'SUPER_ADMIN':
          return ['PROJECT_READ', 'PROJECT_WRITE', 'PROJECT_ADMIN'];
        case 'STAFF':
          return ['PROJECT_READ', 'PROJECT_WRITE'];
        case 'AGENCY':
          return ['PROJECT_READ', 'PROJECT_WRITE'];
        case 'BUSINESS':
        default:
          // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–π —Å–∫–æ—É–ø –¥–ª—è —á—Ç–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø—Ä–æ–µ–∫—Ç–æ–≤
          return ['PROJECT_READ'];
      }
    };

    const payload = {
      sub: user.id,
      email: user.email,
      name: user.name,
      globalRole,
      scopes: scopesByRole(globalRole),
    };

    const [accessToken, refreshToken] = await Promise.all([
      this.jwtService.signAsync(payload, {
        expiresIn: this.configService.get<string>('jwt.accessTokenExpiresIn'),
      }),
      this.jwtService.signAsync(payload, {
        expiresIn: this.configService.get<string>('jwt.refreshTokenExpiresIn'),
      }),
    ]);

    return {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      },
      tokens: {
        accessToken,
        refreshToken,
      },
    } as AuthResponseDto;
  }

  /**
   * –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è
   */
  private async hashPassword(password: string): Promise<string> {
    const saltRounds = 12;
    return bcrypt.hash(password, saltRounds);
  }

  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–¥–∞ –¥–ª—è –≤—Ö–æ–¥–∞
   */
  async sendLoginCode(sendCodeDto: SendCodeDto) {
    const { email, phone, channel } = sendCodeDto;

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email –∏–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω—É
    let user;
    if (email) {
      user = await this.usersService.findByEmail(email);
    } else if (phone) {
      // TODO: –î–æ–±–∞–≤–∏—Ç—å –ø–æ–∏—Å–∫ –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É –≤ UsersService
      throw new BadRequestException('–ü–æ–∏—Å–∫ –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É –ø–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω');
    }

    if (!user) {
      throw new UnauthorizedException('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º 6-–∑–Ω–∞—á–Ω—ã–π –∫–æ–¥ (–≤—Ä–µ–º–µ–Ω–Ω–æ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
    const code = '123456'; // Math.floor(100000 + Math.random() * 900000).toString();
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 –º–∏–Ω—É—Ç

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–¥ (–∏—Å–ø–æ–ª—å–∑—É–µ–º email –∏–ª–∏ phone –∫–∞–∫ –∫–ª—é—á)
    const key = email || phone || '';
    this.loginCodes.set(key, { code, expiresAt, userId: user.id });

    // –õ–æ–≥–∏—Ä—É–µ–º –∫–æ–¥ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    console.log(`üîê –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω –∫–æ–¥ –¥–ª—è ${key}: ${code}`);

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–¥ —á–µ—Ä–µ–∑ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª
    try {
      await this.communicationService.sendMessage(channel as any, {
        to: email || phone || '',
        subject: '–ö–æ–¥ –¥–ª—è –≤—Ö–æ–¥–∞ –≤ Situs Platform',
        content: `–í–∞—à –∫–æ–¥ –¥–ª—è –≤—Ö–æ–¥–∞: ${code}. –ö–æ–¥ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 10 –º–∏–Ω—É—Ç.`,
      });

      return {
        success: true,
        message: '–ö–æ–¥ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω',
        expiresAt: expiresAt.toISOString(),
      };
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–æ–¥–∞:', error);
      throw new BadRequestException('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–æ–¥');
    }
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞ –∏ –≤—Ö–æ–¥
   */
  async verifyLoginCode(verifyCodeDto: VerifyCodeDto): Promise<AuthResponseDto> {
    const { email, phone, code } = verifyCodeDto;

    const key = email || phone || '';
    const storedCodeData = this.loginCodes.get(key);

    if (!storedCodeData) {
      throw new UnauthorizedException('–ö–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –∏—Å—Ç–µ–∫');
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è
    if (new Date() > storedCodeData.expiresAt) {
      this.loginCodes.delete(key);
      throw new UnauthorizedException('–ö–æ–¥ –∏—Å—Ç–µ–∫');
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–¥
    if (storedCodeData.code !== code) {
      throw new UnauthorizedException('–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥');
    }

    // –£–¥–∞–ª—è–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥
    this.loginCodes.delete(key);

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω—ã
    const user = await this.usersService.findById(storedCodeData.userId);
    if (!user) {
      throw new UnauthorizedException('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
    }

    return this.generateTokens(user);
  }

  /**
   * –ü—É–±–ª–∏—á–Ω–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º –ø–æ –∫–æ–¥—É
   */
  async registerPublic(registerPublicDto: RegisterPublicDto): Promise<AuthResponseDto> {
    const { email, phone, name, password, verificationCode } = registerPublicDto;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
    const key = email || phone || '';
    const storedData = this.loginCodes.get(key);

    if (!storedData) {
      throw new BadRequestException('–ù–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ –∏—Å—Ç–µ–∫—à–∏–π –∫–æ–¥');
    }

    // –í—Ä–µ–º–µ–Ω–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º –∑–∞—Ö–∞—Ä–¥–∫–æ–∂–µ–Ω–Ω—ã–π –∫–æ–¥ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    const expectedCode = '123456';
    if (verificationCode !== expectedCode) {
      throw new BadRequestException('–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è');
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    const existingUser = await this.usersService.findByEmailOrPhone(email, phone);
    if (existingUser) {
      throw new ConflictException('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email –∏–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç');
    }

    // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const hashedPassword = await this.hashPassword(password);
    const userData = {
      email,
      phone,
      name,
      password: hashedPassword,
      globalRole: 'USER' as any, // –û–±—ã—á–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –ø–æ–ª—É—á–∞—é—Ç —Ä–æ–ª—å USER
    };

    const user = await this.usersService.create(userData);

    // –£–¥–∞–ª—è–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥
    this.loginCodes.delete(key);

    return this.generateTokens(user);
  }

  /**
   * –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–¥–∞ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –ø–∞—Ä–æ–ª—è
   */
  async forgotPassword(forgotPasswordDto: ForgotPasswordDto): Promise<{ message: string }> {
    const { email, phone, channel } = forgotPasswordDto;

    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await this.usersService.findByEmailOrPhone(email, phone);
    if (!user) {
      // –ù–µ —Ä–∞—Å–∫—Ä—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      return { message: '–ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –∫–æ–¥ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω' };
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∫–æ–¥ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
    const code = Math.floor(100000 + Math.random() * 900000).toString();
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 –º–∏–Ω—É—Ç

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–¥
    const key = email || phone || '';
    this.resetCodes.set(key, {
      code,
      expiresAt,
      userId: user.id,
    });

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–¥
    try {
      await this.communicationService.sendMessage(channel, {
        to: email || phone || '',
        subject: '–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞—Ä–æ–ª—è',
        content: `–í–∞—à –∫–æ–¥ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –ø–∞—Ä–æ–ª—è: ${code}. –ö–æ–¥ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 10 –º–∏–Ω—É—Ç.`,
      });

      console.log(`Reset code for ${email || phone}: ${code}`); // –î–ª—è –æ—Ç–ª–∞–¥–∫–∏
    } catch (error) {
      console.error('Failed to send reset code:', error);
    }

    return { message: '–ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –∫–æ–¥ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω' };
  }

  /**
   * –°–±—Ä–æ—Å –ø–∞—Ä–æ–ª—è –ø–æ –∫–æ–¥—É
   */
  async resetPassword(resetPasswordDto: ResetPasswordDto): Promise<{ message: string }> {
    const { email, phone, code, newPassword } = resetPasswordDto;

    const key = email || phone || '';
    const storedData = this.resetCodes.get(key);

    if (!storedData) {
      throw new BadRequestException('–ù–µ–≤–µ—Ä–Ω—ã–π –∏–ª–∏ –∏—Å—Ç–µ–∫—à–∏–π –∫–æ–¥');
    }

    if (storedData.code !== code) {
      throw new BadRequestException('–ù–µ–≤–µ—Ä–Ω—ã–π –∫–æ–¥');
    }

    if (new Date() > storedData.expiresAt) {
      this.resetCodes.delete(key);
      throw new BadRequestException('–ö–æ–¥ –∏—Å—Ç–µ–∫');
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞—Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const hashedPassword = await this.hashPassword(newPassword);
    await this.usersService.updatePassword(storedData.userId, hashedPassword);

    // –£–¥–∞–ª—è–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥
    this.resetCodes.delete(key);

    return { message: '–ü–∞—Ä–æ–ª—å —É—Å–ø–µ—à–Ω–æ –∏–∑–º–µ–Ω–µ–Ω' };
  }

  /**
   * –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–∞—Ä–æ–ª–µ–π
   */
  private async comparePasswords(password: string, hashedPassword: string): Promise<boolean> {
    return bcrypt.compare(password, hashedPassword);
  }
}
